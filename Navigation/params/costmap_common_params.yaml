
#
# Common Configuration (local_costmap) & (global_costmap)
#

# Sensors
obstacle_range: 5.5 # The maximum range in meters at which to insert obstacles into the costmap using sensor data.
raytrace_range: 6.0 # The maximum range in meters at which to raytrace out obstacles from the map using sensor data.
inf_is_valid: false  # Allows for Inf values in "LaserScan" observation messages. The Inf values are converted to the laser maximun range.

# Robot Specific
footprint: [[ 0.765, 0.765], [ -0.765, 0.765], [ -0.765, -0.765], [ 0.765, -0.765]] # corrected to include tires in the footprint
footprint_padding: 0.10 # 10cm buffer for safety. maybe change for more precision
inflation_radius: 1.08 
transform_tolerance: 1 # Specifies the delay in transform (tf) data that is tolerable in seconds.
controller_patience: 2.0 # How long the controller will wait in seconds without receiving a valid control before space-clearing operations are performed.


# base global planner
NavfnROS:
   allow_unknown: true # Specifies whether or not to allow navfn to create plans that traverse unknown space.

recovery_behavior_enabled: false

plugins:
  - {name: obstacles_layer, type: "costmap_2d::ObstacleLayer"}
  - {name: inflater_layer, type: "costmap_2d::InflationLayer"}


#
# Remove recovery behaviors for debugging purposes
#

#recovery_behaviors: [
#    {name: conservative_clear, type: clear_costmap_recovery/ClearCostmapRecovery},
#    {name: aggressive_clear, type: clear_costmap_recovery/ClearCostmapRecovery}
#]
#conservative_clear: reset_distance: 3.00
#aggressive_clear: reset_distance: 1.84

obstacles_layer:

  observation_sources: point_cloud_sensorA point_cloud_sensorB

  # assuming receiving a cloud from rtabmap_ros/obstacles_detection node
  # we also want to use the LIDAR to place and clear items in the local costmap


  point_cloud_sensorA: {
    sensor_frame: base_link,
    data_type: PointCloud2,
    topic: /obstacles,
    marking: true,
    clearing: true,
    min_obstacle_height: 0.04,
    max_obstacle_height: 3.0
  }


  point_cloud_sensorB: {
    sensor_frame: base_link,
    data_type: PointCloud2,
    topic: /ground,
    marking: false,
    clearing: true,
    min_obstacle_height: -1.0,
    max_obstacle_height: 0.0
  }


